Allocator :: func(size: u64, op: Alloc_Op, allocator_data: *void, old_ptr: *byte, old_size: u64, align: u64) *byte;

Arena :: struct {
  data:     *byte;
  capacity: u64;
  size:     u64;
}

arena_make :: func(data: *byte, capacity: u64) Arena {
  result: Arena;
  result.data = data;
  result.capacity = capacity;
  return result;
}

Context :: struct {
  allocator:      Allocator;
  allocator_data: *void;
  scratch:        Arena;
}

arena_alloc :: func(size: u64, op: Alloc_Op, allocator_data: *void, old_ptr: *byte, old_size: u64, align: u64) *byte {
  arena :: (*Arena)(allocator_data);
  if op == Alloc_Op.ALLOC {
    result := arena.data + arena.size; // TODO pointer arithmetic, right now this is wrong
    arena.size += size;
    return result;
  } else if op == Alloc_Op.FREE_ALL {
    arena.size = u64(0);
  }
}

test :: func(a: i32) i32 {
  return a*2;
}

main :: func() i32 {
  fjdksl := "blabla";
  aa := test(43);
}

__string_make :: func(data: *char, count: u64) string {
  result: string;
  result.data = data;
  result.count = count;
  return result;
}


string :: struct {
  data:  *char;
  count: u64;
}


Alloc_Op :: enum {
  ALLOC;
  REALLOC;
  FREE;
  FREE_ALL;
}


__Array_Dynamic :: struct {
  data:           *void;
  count:          i32;
  capacity:       i32;

  allocator:      Allocator;
  allocator_data: *void;
}
